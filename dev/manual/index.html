<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · TeaSeis</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">TeaSeis</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">TeaSeis</a></li><li class="is-active"><a class="tocitem" href>Manual</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Obtaining-TeaSeis.jl"><span>Obtaining TeaSeis.jl</span></a></li><li class="toplevel"><a class="tocitem" href="#Using-TeaSeis.jl"><span>Using TeaSeis.jl</span></a></li><li><a class="tocitem" href="#Quick-start-guide"><span>Quick start guide</span></a></li><li><a class="tocitem" href="#writing"><span>writing</span></a></li><li><a class="tocitem" href="#reading"><span>reading</span></a></li><li class="toplevel"><a class="tocitem" href="#jsopen-/-jscreate"><span>jsopen / jscreate</span></a></li><li class="toplevel"><a class="tocitem" href="#Available-options-when-creating-a-new-JavaSeis-file"><span>Available options when creating a new JavaSeis file</span></a></li><li class="toplevel"><a class="tocitem" href="#Read/write-methods"><span>Read/write methods</span></a></li><li><a class="tocitem" href="#Alternative-read/write-methods-(N-Dimensional-slices)"><span>Alternative read/write methods (N-Dimensional slices)</span></a></li><li><a class="tocitem" href="#Alternative-write-methods-for-full-frames"><span>Alternative write methods for full frames</span></a></li><li class="toplevel"><a class="tocitem" href="#Trace-Properties"><span>Trace Properties</span></a></li><li><a class="tocitem" href="#TRC_TYPE"><span>TRC_TYPE</span></a></li><li class="toplevel"><a class="tocitem" href="#Data-properties"><span>Data properties</span></a></li><li class="toplevel"><a class="tocitem" href="#Secondaries"><span>Secondaries</span></a></li><li class="toplevel"><a class="tocitem" href="#Geometry"><span>Geometry</span></a></li><li class="toplevel"><a class="tocitem" href="#Convenience-methods-and-dictionaries"><span>Convenience methods and dictionaries</span></a></li></ul></li><li><a class="tocitem" href="../reference/">Reference</a></li><li><a class="tocitem" href="../STOCKPROPS/">Stock properties</a></li><li><a class="tocitem" href="../SSPROPS/">SeisSpace properties</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Manual</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Manual</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ChevronETC/TeaSeis.jl/blob/master/docs/src/manual.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Manual"><a class="docs-heading-anchor" href="#Manual">Manual</a><a id="Manual-1"></a><a class="docs-heading-anchor-permalink" href="#Manual" title="Permalink"></a></h1><h1 id="Obtaining-TeaSeis.jl"><a class="docs-heading-anchor" href="#Obtaining-TeaSeis.jl">Obtaining TeaSeis.jl</a><a id="Obtaining-TeaSeis.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Obtaining-TeaSeis.jl" title="Permalink"></a></h1><pre><code class="language-none">Pkg.add(&quot;TeaSeis&quot;)</code></pre><h1 id="Using-TeaSeis.jl"><a class="docs-heading-anchor" href="#Using-TeaSeis.jl">Using TeaSeis.jl</a><a id="Using-TeaSeis.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Using-TeaSeis.jl" title="Permalink"></a></h1><h2 id="Quick-start-guide"><a class="docs-heading-anchor" href="#Quick-start-guide">Quick start guide</a><a id="Quick-start-guide-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-start-guide" title="Permalink"></a></h2><p>First, load  the TeaSeis.jl library:</p><pre><code class="language-julia">using TeaSeis</code></pre><h2 id="writing"><a class="docs-heading-anchor" href="#writing">writing</a><a id="writing-1"></a><a class="docs-heading-anchor-permalink" href="#writing" title="Permalink"></a></h2><ul><li>Create a new JavaSeis file with a 3D framework (128 samples per trace, 32 traces per frame, and 16 frames per volume):</li></ul><pre><code class="language-julia">io = jsopen(&quot;filename.js&quot;, &quot;w&quot;, axis_lengths=[128, 32, 16])</code></pre><p>Note that by default, <code>SAMPLE</code>, <code>TRACE</code>, and <code>FRAME</code> will be the axes properties.</p><ul><li>Allocate traces and headers for a single frame:</li></ul><pre><code class="language-julia">trcs, hdrs = allocframe(io)</code></pre><ul><li>Populate <code>trcs</code>, and <code>hdrs</code> with values.  For example, write random values to all traces in the first frame:</li></ul><pre><code class="language-julia">map(i-&gt;set!(prop(io, stockprop[:TRC_TYPE]), hdrs, i, tracetype[:live]), 1:size(io,2))
map(i-&gt;set!(prop(io, stockprop[:TRACE]   ), hdrs, i, i               ), 1:size(io,2))
map(i-&gt;set!(prop(io, stockprop[:FRAME]   ), hdrs, i, 1               ), 1:size(io,2))
rand!(trcs)
writeframe(io, trcs, hdrs)</code></pre><ul><li>Close the file</li></ul><pre><code class="language-julia">close(io)</code></pre><h2 id="reading"><a class="docs-heading-anchor" href="#reading">reading</a><a id="reading-1"></a><a class="docs-heading-anchor-permalink" href="#reading" title="Permalink"></a></h2><ul><li>Open a new JavaSeis file from an existing dataset:</li></ul><pre><code class="language-julia">io = jsopen(&quot;filename.js&quot;, &quot;r&quot;)</code></pre><ul><li>Read the first frame:</li></ul><pre><code class="language-julia">trcs, hdrs = readframe(io, 1)</code></pre><p>or a similar in-place version:</p><pre><code class="language-julia">trcs, hdrs = allocframe(io)
readframe!(io, trcs, hdrs, 1)</code></pre><ul><li>Access values stored in a trace property for the first trace in the frame:</li></ul><pre><code class="language-julia">get(prop(io, stockprop[:TRACE]), hdrs, 1)</code></pre><p>or, slightly less efficient:</p><pre><code class="language-julia">get(prop(io, stockprop[:TRACE]), hdrs[:,1])</code></pre><ul><li>Close the file</li></ul><pre><code class="language-julia">close(io)</code></pre><h1 id="jsopen-/-jscreate"><a class="docs-heading-anchor" href="#jsopen-/-jscreate">jsopen / jscreate</a><a id="jsopen-/-jscreate-1"></a><a class="docs-heading-anchor-permalink" href="#jsopen-/-jscreate" title="Permalink"></a></h1><p>A JavaSeis dataset is created/opened with the <code>jsopen</code> method which returns a <code>JSeis</code>. A JavaSeis dataset must have a minimum of 3 dimensions.  </p><p>Create a 3D JavaSeis file with 10 samples per trace, 11 traces per frame, and 12 frames per volume:</p><pre><code class="language-julia">io = jsopen(&quot;file.js&quot;, &quot;w&quot;, axis_lengths=[10,11,12])</code></pre><p>Open an existing JavaSeis file in read-only mode:</p><pre><code class="language-julia">io = jsopen(&quot;file.js&quot;, &quot;r&quot;)
io = jsopen(&quot;file.js&quot;)      # equivalent to previous line</code></pre><p>Open an existing JavaSeis file for reading and writing:</p><pre><code class="language-julia">io = jsopen(&quot;file.js&quot;, &quot;r+&quot;)</code></pre><p>To close an open dataset:</p><pre><code class="language-julia">close(io)</code></pre><p>To create a dataset:</p><pre><code class="language-julia">jscreate(&quot;file.js&quot;, axis_lengths=[10,11,12])</code></pre><p>This is useful for when you need to create the data-set on the master process, and write to it on worker processes.</p><h1 id="Available-options-when-creating-a-new-JavaSeis-file"><a class="docs-heading-anchor" href="#Available-options-when-creating-a-new-JavaSeis-file">Available options when creating a new JavaSeis file</a><a id="Available-options-when-creating-a-new-JavaSeis-file-1"></a><a class="docs-heading-anchor-permalink" href="#Available-options-when-creating-a-new-JavaSeis-file" title="Permalink"></a></h1><p>The <code>jscreate</code> and, when operating in write <code>&quot;w&quot;</code> mode, <code>jsopen</code> functions take the following named optional arguments:</p><ul><li><code>similarto::String</code></li></ul><p>An existing JavaSeis dataset.  If set, then all other named arguments can be used to modify the data context that belongs to the existing JavaSeis dataset.</p><ul><li><code>description::String</code></li></ul><p>Description of dataset, if not set, then a description is parsed from the filename.</p><ul><li><code>mapped::Bool</code></li></ul><p>If the dataset is full (no missing frames/traces), then it may be more efficient to set this to <code>false</code>.  Defaults to <code>true</code>.</p><ul><li><code>nextents::Int</code></li></ul><p>The number of file-extents used to store the data.  If not set, then a heuristic is used to choose the number of extents.</p><ul><li><code>secondaries::Array{String, 1}</code></li></ul><p>An array of file-system locations used to store the file extents.  If not set, then <em>primary</em> storage is used.</p><ul><li><code>datatype::String</code></li></ul><p>Examples are <code>CMP</code>, <code>SHOT</code>, etc.  If not set, then <code>UNKNOWN</code> is used.</p><ul><li><code>dataformat::Type</code></li></ul><p>Choose from <code>Float32</code>, and <code>Int16</code>.  If not set, then <code>Float32</code> is used.</p><ul><li><code>dataorder::String</code></li></ul><p>(not supported)</p><ul><li><code>axis_propdefs::Array{TracePropertyDef, 1}</code></li></ul><p>Trace properties corresponding to JavaSeis axes.  If not set, then <code>SAMPLE</code>, <code>TRACE</code>, <code>FRAME</code>, <code>VOLUME</code> and <code>HYPRCUBE</code> are used.</p><ul><li><code>axis_units::Array{String, 1}</code></li></ul><p>Units corresponding to JavaSeis axes. e.g. <code>SECONDS</code>, <code>METERS</code>, etc.  If not set, then <code>UNKNOWN</code> is used.</p><ul><li><code>axis_domains::Array{String, 1}</code></li></ul><p>Domains corresponding to JavaSeis axes. e.g. <code>SPACE</code>, <code>TIME</code>, etc.  If not set, then <code>UNKNOWN</code> is used.</p><ul><li><code>axis_lstarts::Array{Int32, 1}</code></li></ul><p>Logical origins for each axis.  If not set, then <code>1</code> is used for the logical origin of each axis.</p><ul><li><code>axis_lincs::Array{Int32, 1}</code></li></ul><p>Logical increments for each axis.  If not set, then <code>1</code> is used for the logical increments of each axis.</p><ul><li><code>axis_pstarts::Array{Float64, 1}</code></li></ul><p>Physical origins for each axis.  If not set, then <code>0.0</code> is used for the physical origin of each axis.</p><ul><li><code>axis_pincs::Array{Float64, 1}</code></li></ul><p>Physical increments for each axis.  If not set, then <code>1.0</code> is used for the physical increments of each axis.</p><ul><li><code>properties::Array{TracePropertyDef, 1}</code></li></ul><p>An array of custom trace properties.  These are in addition to a minimal set of trace properties listed in the ProMax manual.</p><ul><li><code>dataproperties::Array{DataProperty, 1}</code></li></ul><p>An array of custom data properties.  One property per data-set rather than one property per trace as in <code>properties</code> above.</p><ul><li><code>geometry::Geometry</code></li></ul><p>An optional three point geometry can be embedded in the JavaSeis file.</p><ul><li><code>properties_add::Array{TracePropertyDef}</code></li></ul><p>When <code>similarto</code> is specified, use this to add trace properties to those already existing in the <code>similarto</code> file.</p><ul><li><code>properties_rm::Array{TracePropertyDef}</code></li></ul><p>When <code>similarto</code> is specified, use this to remove trace properties to those already existing in the <code>similarto</code> file.</p><ul><li><code>dataproperties_add::Array{DataProperty}</code></li></ul><p>When <code>similarto</code> is specfied, use this to add dataset properties to those aloready existing in the <code>similarto</code> file.</p><ul><li><code>dataproperties_rm::Array{DataProperty}</code></li></ul><p>When <code>similarto</code> is specified, use this to remove dataset properties to those already existing in the <code>similarto</code> file.</p><p>For example:</p><pre><code class="language-julia">io = jsopen(&quot;file.js&quot;, &quot;w&quot;, axis_lengths=[10,11,12], dataformat=Float16, axis_pincs=[0.004,10.0,20.0])</code></pre><h1 id="Read/write-methods"><a class="docs-heading-anchor" href="#Read/write-methods">Read/write methods</a><a id="Read/write-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Read/write-methods" title="Permalink"></a></h1><p>JavaSeis is a frame based file format.</p><p>For <code>io::JSeis</code>, allocate memory for a single frame:</p><pre><code class="language-julia">trcs, hdrs = allocframe(io) # allocate memory for traces and headers for a single frame
trcs = allocframetrcs(io)   # allocate memory for traces for a single frame
hdrs = allocframehdrs(io)   # allocate memory for headers for a single frame</code></pre><p>Read a frame. <code>ifrm::Int</code>, <code>ivol::Int</code>, <code>ihyp::Int</code> and <code>i6::Int</code> must be consistent with the JavaSeis data context.</p><pre><code class="language-julia">trcs, hdrs = readframe(io, ifrm)                 # read from 3D data
trcs, hdrs = readframe(io, ifrm, ivol)           # read from 4D data
trcs, hdrs = readframe(io, ifrm, ivol, ihyp)     # read from 5D data
trcs, hdrs = readframe(io, ifrm, ivol, ihyp, i6) # read from 6D data
...</code></pre><p>Read a frame (in-place) using pre-allocated memory:</p><pre><code class="language-julia">ifrm = 1
readframe!(io, trcs, hdrs, ifrm)                # read from 3D data
readframe!(io, trcs, hdrs, ifrm, ivol)          # read from 4D data
readframe!(io, trcs, hdrs, ifrm, ivol, ihyp)    # read from 5D data
readframe!(io, trcs, hdrs, ifrm, ivol, ihyp, i6) # read from 6D data
...</code></pre><p>Note that <code>readframe!</code> methods returns the *fold** (number of live traces in the frame).</p><p>Similar methods exist for reading only headers:</p><pre><code class="language-julia">ifrm = 1
hdrs = readframehdrs(io, ifrm)                 # read from 3D data
hdrs = readframehdrs(io, ifrm, ivol)           # read from 4D data
hdrs = readframehdrs(io, ifrm, ivol, ihyp)     # read from 5D data
hdrs = readframehdrs(io, ifrm, ivol, ihyp, i6) # read from 6D data
...
readframehdrs!(io, hdrs, ifrm)                 # in-place read from 3D data
readframehdrs!(io, hdrs, ifrm, ivol)           # in-place read from 4D data
readframehdrs!(io, hdrs, ifrm, ivol, ihyp)     # in-place read from 5D data
readframehdrs!(io, hdrs, ifrm, ivol, ihyp, i6) # in-place read from 6D data
...</code></pre><p>or only traces:</p><pre><code class="language-julia">ifrm = 1
trcs = readframetrcs(io, ifrm)                 # read from 3D data
trcs = readframetrcs(io, ifrm, ivol)           # read from 4D data
trcs = readframetrcs(io, ifrm, ivol, ihyp)     # read from 5D data
trcs = readframetrcs(io, ifrm, ivol, ihyp, i6) # read from 6D data
...
readframetrcs!(io, trcs, ifrm)                 # in-place read from 3D data
readframetrcs!(io, trcs, ifrm, ivol)           # in-place read from 4D data
readframetrcs!(io, trcs, ifrm, ivol, ihyp)     # in-place read from 5D data
readframetrcs!(io, trcs, ifrm, ivol, ihyp, i6) # in-place read from 6D data
...</code></pre><p>Write a frame. The frame, volume, and hypercube indices are determined from the trace properties (<code>hdrs::Array{UInt8,2}</code>)</p><pre><code class="language-julia">writeframe(io, trcs, hdrs)</code></pre><p>To loop over all frames in a dataset of arbitrary dimension, TeaSeis.jl provides an iterator-type API:</p><pre><code class="language-julia">for i=1:length(io)
    trcs, hdrs = readframe(io, ind2sub(io,i)...)
end</code></pre><p>where <code>length(io)</code> is the number of frames in <code>io</code>, <code>ind2sub</code> converts the linear index <code>i</code> into n-tuple indexing dimensions 3 and higher.  Of course, this can also be used with <code>readframe!</code>, <code>readframetrcs</code>, <code>readframetrcs!</code>, <code>readframehdrs</code> and <code>readframehdrs!</code>.</p><h3 id="IMPORTANT-NOTE:"><a class="docs-heading-anchor" href="#IMPORTANT-NOTE:">IMPORTANT NOTE:</a><a id="IMPORTANT-NOTE:-1"></a><a class="docs-heading-anchor-permalink" href="#IMPORTANT-NOTE:" title="Permalink"></a></h3><p>It is <strong>very</strong> important to note that the JavaSeis format left-justifies all live traces in a frame.  This makes reading and writing data more efficient. However, if you are reading or writing non-full frames, extra care must be taken.  Two methods (<code>leftjustify!</code> and <code>regularize!</code>) are provided to help with this situation.</p><p>Writing a non-full frame:</p><pre><code class="language-julia">leftjustify!(io, trcs, hdrs)
writeframe(io, trcs, hdrs)</code></pre><p>Reading a non-full frame:</p><pre><code class="language-julia">readframe!(io, trcs, hdrs, 1)
regularize!(io, trcs, hdrs)
regularize!(io, trcs, hdrs, stockprop[:TRACE]) # used when the trace label does not correspond to a trace property</code></pre><p>Please note that the regularize method sets the <code>:TRC_TYPE</code> property appropriately.  That is, a padded trace is of <code>tracetype[:dead]</code>.</p><p>Methods for finding the fold of a frame:</p><pre><code class="language-julia">fold(io, hdrs)                 # get fold by examining the headers `hdrs` from a frame
fold(io, ifrm)                 # get fold from a 3D data set using the JavaSeis `TraceMap` file
fold(io, ifrm, ivol)           # get fold from a 4D data set using the JavaSeis `TraceMap` file
fold(io, ifrm, ivol, ihyp)     # get fold from a 5D data set using the JavaSeis `TraceMap` file
fold(io, ifrm, ivol, ihyp, i6) # get fold from a 6D data set using the JavaSeis `TraceMap` file
...</code></pre><h2 id="Alternative-read/write-methods-(N-Dimensional-slices)"><a class="docs-heading-anchor" href="#Alternative-read/write-methods-(N-Dimensional-slices)">Alternative read/write methods (N-Dimensional slices)</a><a id="Alternative-read/write-methods-(N-Dimensional-slices)-1"></a><a class="docs-heading-anchor-permalink" href="#Alternative-read/write-methods-(N-Dimensional-slices)" title="Permalink"></a></h2><p>We supply convenience methods for reading and writing arbitrary patches of data.  If frames are not full, then the read algorithms include automatic regularization of the frames, and the write algorithms include automatic left justification.  In turn, this means that the convenience of the following methods may come at the expense of extra I/O operations.  This is especially true for JavaSeis datasets that are of 6 or more dimensions.</p><p><strong>Reading:</strong></p><pre><code class="language-julia">trcs, hdrs = read(io, 1:10, 2:3, 4)              # read from 3D data (frame 4, traces 2-3, and time samples 1-10)
trcs, hdrs = read(io, 1:10, 2:3, 4, :)           # read from 4D data (all volumes, frame 4, traces 2-3, and time samples 1-10)
trcs, hdrs = read(io, 1:10, 2:3, 4, :, 2:2:4)    # read from 5D data (Hypercubes 2 and 4, all volumes, frame 4, traces 2-3 and time samples 1-10)
trcs, hdrs = read(io, 1:10, 2:3, 4, :, 2:2:4, 1) # read from 6D data (element 1 from the 6th dimension, hypercubes 2 and 4, all volumnes, frame 4, traces 2-3 and time samples 1-10)
...
read!(io, trcs, hdrs, 1:10, 2:3, 4)              # in-place read from 3D data
read!(io, trcs, hdrs, 1:10, 2:3, 4, :)           # in-place read from 4D data
read!(io, trcs, hdrs, 1:10, 2:3, 4, :, 2:2:4)    # in-place read from 5D data
read!(io, trcs, hdrs, 1:10, 2:3, 4, :, 2:2:4, 1) # in-place read from 6D data
...</code></pre><p>Similar methods exist for reading only traces (for example):</p><pre><code class="language-julia">trcs = readtrcs(io, 1:10, 2:3, 4)
readtrcs!(io, trcs, 1:10, 2:3, 4) # in-place version of previous line</code></pre><p>and only headers (for example):</p><pre><code class="language-julia">hdrs = readhdrs(io, :, 2:3, 4)
readhdrs!(io, hdrs, :, 2:3, 4) # in-place version of previous line//</code></pre><p>Note that when using <code>readhdrs</code> and <code>readhdrs!</code> the slice range for the first dimension is always <code>:</code>.</p><p><strong>Writing:</strong></p><pre><code class="language-julia">write(io, trcs, hdrs)       # trcs::Array{Float32,N}, hdrs::Array{Float32,N} where N is either 3,4 or 5.
write(io, trcs, hdrs, 1:10) # same as previous except only time samples 1:10 are written.</code></pre><p>In the above listing, the locations that are written to are determined by the header values.</p><h2 id="Alternative-write-methods-for-full-frames"><a class="docs-heading-anchor" href="#Alternative-write-methods-for-full-frames">Alternative write methods for full frames</a><a id="Alternative-write-methods-for-full-frames-1"></a><a class="docs-heading-anchor-permalink" href="#Alternative-write-methods-for-full-frames" title="Permalink"></a></h2><p>it is sometimes not convenient to set headers before writing full frames.  This might be true when, for example, one is doing research work where geometry (and other) information does not need to be stored in trace headers.  For this scenario, we provide two sets of alternative API.</p><p>The first set of API is for writing one frame at a time:</p><pre><code class="language-julia">writeframe(io, trcs, ifrm)                 # write to 3D data
writeframe(io, trcs, ifrm, ivol)           # write to 4D data
writeframe(io, trcs, ifrm, ivol, ihyp)     # write to 5D data
writeframe(io, trcs, ifrm, ivol, ihyp, i6) # write to 6D data
...</code></pre><p>The second set of API is for writing arbitrary N-dimensional slices of data:</p><pre><code class="language-julia">write(io, trcs, :, 1:10, 3:2:5)            # write to 3D data, all samples; traces 1-10; frames 3, 5
write(io, trcs, :, 1:10, 3:2:5, 6)         # write to 4D data, all samples; traces 1-10; frames 3, 5; volume 6
write(io, trcs, :, 1:10, 3:2:5, 6, :)      # write to 5D data, all samples; traces 1-10; frames 3, 5; volume 6, all hypercubes
write(io, trcs, :, 1:10, 3:2:5, 6, :, 1:2) # write to 6D data, all samples; traces 1-10; frames 3, 5; volume 6, all hypercubes, elements 1 and 2 from dimension 6
...</code></pre><p>Please note that in these forms, the writeframe and write methods will create headers for you, and populate the <code>:TRC_TYPE</code> property along with the properties corresponding to the trace and frame axes of your data.  In the case of 4D data, the volume property is also populated, and in the case of 5D data, the volume and hypercube properties are also populated.</p><p>In addition, please note that in the <code>write</code> method, <code>trcs</code> must have the same number of dimensions as <code>io</code>.  In practice this can be accomplished using <code>reshape</code>.  For example if <code>size(io)=(10,20,3)</code> and <code>size(trcs)=(10,)</code>, then to write <code>trcs</code> to the first trace of the first frame of <code>io</code> one could write:</p><pre><code class="language-julia">write(io, rehsape(trcs, 10, 1, 1), :, 1, 1)</code></pre><h1 id="Trace-Properties"><a class="docs-heading-anchor" href="#Trace-Properties">Trace Properties</a><a id="Trace-Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Trace-Properties" title="Permalink"></a></h1><p>The JavaSeis data format does not specify any trace properties.  However, there are commonly used (<strong>stock</strong>) properties (listed in <a href="../STOCKPROPS/">STOCKPROPS.md</a>, as well as a minimal set of properties that are expected by SeisSpace (listed in <a href="../SSPROPS/">SSPROPS.md</a>).  It is unusual when a stock property does not suit your needs.  But, if need be, you can define a custom property using the <code>TracePropertyDef</code> constructor:</p><pre><code class="language-julia">pdef = TracePropertyDef(&quot;label&quot;, &quot;description&quot;, Float32)
pdef = TracePropertyDef(&quot;label&quot;, &quot;description&quot;, Vector{Float32}, 2)</code></pre><p>The arguments to <code>TracePropertyDef</code> are the <strong>label</strong>, <strong>description</strong>, <strong>type</strong>, and, optionally, the <strong>number of elements</strong> stored in the property. The stock properties are defined in <code>src/stockprops.jl</code> using a Julia dictionary: <code>stockprop</code>.  For example, access a stock definition for the <code>TRACE</code> property:</p><pre><code class="language-julia">pdef = stockprop[:TRACE]</code></pre><p>Given a JavaSeis file <code>io::JSeis</code> and a stock definition, we can access the corresponding property of a JavaSeis file:</p><pre><code class="language-julia">p = prop(io, pdef)    # access using a `TracePropertyDef`
p = prop(io, &quot;TRACE&quot;) # alternatively, access using the trace property definition label
p = prop(io, &quot;TRACE&quot;, Int32) # type-stable version of previous line</code></pre><p>Given, additionally, a frame of headers <code>hdrs::Array{UInt8,2}</code>, we can get and set the values stored in a property:</p><pre><code class="language-julia">@show get(p, hdrs[:,1])
@show get(p, hdrs, 1)      # equivalent to the previous line of code
set!(p, hdrs, 1, 5)        # set the first header in `hdrs` to 5
writeframe(io, trcs, hdrs) # the JavaSeis file does not know about the updated header until you call `writeframe`</code></pre><p>In the above code listing <code>trcs</code> is of type <code>Array{Float32,2}</code>.</p><h2 id="TRC_TYPE"><a class="docs-heading-anchor" href="#TRC_TYPE">TRC_TYPE</a><a id="TRC_TYPE-1"></a><a class="docs-heading-anchor-permalink" href="#TRC_TYPE" title="Permalink"></a></h2><p>The <code>TRC_TYPE</code> property is used to indicate if a trace is dead, live or auxiliary within any given frame.  It is stored as an <code>Int32</code>.  We provide a second dictionary to map between the <code>Int32</code> and human readable code:</p><pre><code class="language-julia">tracetype[:live]
tracetype[:dead]
tracetype[:aux]</code></pre><p>For example,</p><pre><code class="language-julia">io = jsopen(&quot;file.js&quot;, &quot;r&quot;)
trcs, hdrs = readframe(io, 1)
prop_trctype = prop(io, stockprop[:TRC_TYPE])
for i=1:size(hdrs,2)
    if get(prop_trctype, hdrs, i) == tracetype[:live]
        write(STDOUT, &quot;trace $(i) is a live trace\n&quot;)
    elseif get(prop_trctype, hdrs, i) == tracetype[:dead]
        write(STDOUT, &quot;trace $(i) is a dead trace\n&quot;)
    elseif get(prop_trctype, hdrs, i) == tracetype[:aux]
        write(STDOUT, &quot;trace $(i) is a aux trace\n&quot;
    end
end
close(io)</code></pre><h1 id="Data-properties"><a class="docs-heading-anchor" href="#Data-properties">Data properties</a><a id="Data-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Data-properties" title="Permalink"></a></h1><p>TeaSeis.jl provides support for storing custum data properties.  This is accomplished by passing an array of <code>DataProperty</code>&#39;s to the <code>jsopen</code> function.  For example, a data property could be defined as:</p><pre><code class="language-julia">p = DataProperty(&quot;Survey date&quot;, Int32, 120977&quot;)</code></pre><h1 id="Secondaries"><a class="docs-heading-anchor" href="#Secondaries">Secondaries</a><a id="Secondaries-1"></a><a class="docs-heading-anchor-permalink" href="#Secondaries" title="Permalink"></a></h1><p>If you choose to use secondary storage, then it is recommended to set the <code>JAVASEIS_DATA_HOME</code> environment variable.  This is used to determine the file-path for the secondary storage.  For example if,</p><pre><code class="language-none">ENV[&quot;JAVASEIS_DATA_HOME&quot;] = &quot;/home/joe/projects&quot;
cd(&quot;/home/joe/projects/some/dir/here&quot;)
io = jsopen(&quot;data.js&quot;, &quot;w&quot;, axis_lengths=[10,11,12], secondaries=[&quot;/bigdisk/joe&quot;])
close(io)</code></pre><p>Then the secondary location is determined by replacing <code>/home/joe/projects</code> in <code>/home/joe/projects/some/dir/here/data.js</code> with <code>/bigdisk/joe</code> resulting in <code>/bigdisk/joe/some/dir/here/data.js</code> being the secondary storage for this example.</p><h1 id="Geometry"><a class="docs-heading-anchor" href="#Geometry">Geometry</a><a id="Geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Geometry" title="Permalink"></a></h1><p>TeaSeis.jl provides support for storing survey geometry using three-points to define rotated/translated coordinate system.</p><pre><code class="language-julia">geom = Geometry(u1=1,un=2,v1=1,vn=2,w1=1,wn=2,ux=1.0,uy=0.0,uz=0.0,vx=0.0,vy=1.0,vz=0.0,wx=0.0,wy=0.0,wz=1.0)</code></pre><p>where <code>(ox,oy,oz)</code> is the origin, <code>(ux,uy,uz)</code> is a vector to define the end of the <code>u-axis</code> (e.g. cross-line axis), <code>(vx,vy,vz)</code> is the end of the <code>v-axis</code> (e.g. the in-line axis), and <code>(wx,wy,wz)</code> is the end of the <code>w-axis</code> (e.g. the depth axis).  <code>(u1,un)</code> are the first and last bin indices along the <code>u-axis</code>, <code>(v1,vn)</code> are the first and last bin indices along the <code>v-axis</code>, and <code>(w1,wn)</code> are the first and last bin indices along the <code>w-axis</code>.  TeaSeis.jl does not provide any tools for using this geometry to manipulate trace coordinates.  I would recommend that this functionality be put into a separate package.</p><p><img src="../geometry.png" alt="Geometry"/></p><h1 id="Convenience-methods-and-dictionaries"><a class="docs-heading-anchor" href="#Convenience-methods-and-dictionaries">Convenience methods and dictionaries</a><a id="Convenience-methods-and-dictionaries-1"></a><a class="docs-heading-anchor-permalink" href="#Convenience-methods-and-dictionaries" title="Permalink"></a></h1><p>For convenience and consistency, we supply several dictionaries.  In addition to the dictionary for trace property definitions and trace type (both described above), there are dictionaries for <strong>data domain</strong> <code>stockdomain</code>, <strong>units</strong> <code>stockunit</code>, and <strong>data type</strong> <code>stockdatatype</code>.  All of these are listed in <a href="../STOCKPROPS/">STOCKPROPS.md</a>.</p><p>Example usage within the jsopen method:</p><pre><code class="language-julia">io = jsopen(&quot;file.js&quot;, &quot;w&quot;, axis_lengths=[12,11,10], axis_units=[stockunit[:SECONDS], stockunit[:METERS], stockunit[:METERS]], axis_domains=[stockdomain[:TIME], stockdomain[:SPACE], stockdomain[:SPACE], datatype=stockdatatype[:SOURCE])</code></pre><p>Several convenience methods are supplied for querying <code>io::JSeis</code>:</p><pre><code class="language-julia">ndims(io)              # returns `Int`, number of dimensions in the JavaSeis dataset
length(io)             # returns `Int`, the number of frames in the JavaSeis dataset, equivalent to `prod(size(io)[3:end])`
size(io)               # returns `NTuple{Int}`, size of JavaSeis dataset
size(io,i)             # returns `Int`, size of JavaSeis dataset along dimension `i::Int`
props(io)              # returns `NTuple{TraceProperty}`, trace property along all dimensions
props(io,i)            # returns `TraceProperty`, trace property along dimension `i::Int`
propdefs(io)           # returns `NTuple{TracePropertyDef}`, trace property definition along all dimensions
propdefs(io,i)         # returns `TracePropertyDef`, trace property along dimension `i::Int`
labels(io)             # returns `NTuple{String}`, trace property labels along all dimensions
labels(io,i)           # returns `String`, trace property label along dimension `i::Int`
units(io)              # returns `NTuple{String}`, units along all dimensions
units(io,i)            # returns `String, unit along dimension `i::Int`
domains(io)            # returns `NTuple{String}`, data domains along all dimensions
domains(io,i)          # returns `String`, data domain along dimension `i::Int`
pstarts(io)            # returns `NTuple{Float64}`, physical starts along all dimensions
pstarts(io,i)          # returns `Float64`, physical start along dimension `i::Int`
pincs(io)              # returns `NTuple{Float64}`, physical increments along all dimensions
pincs(io,i)            # returns `Float64`, physical increment along dimension `i::Int`
lstarts(io)            # returns `NTuple{Int32}`, logical starts along all dimensions
lstarts(io,i)          # returns `Int32`, logical start along dimension `i::Int`
lincs(io)              # returns `NTuple{Int32}`, logical increments along all dimensions
lincs(io,i)            # returns `Int32`, logical increment along dimension `i::Int`
lrange(io)             # returns `NTuple{StepRange{Int64}}`, logical range along all dimensions
lrange(io,i)           # returns `StepRange{Int64}`, logical range along dimension `i::Int`
isempty(io)            # returns true if the dataset is empty (without trace or header extents)
in(prop,io)            # returns true if the trace property `prop` exists in `io` --  `prop` can be of types `::TraceProperty`, `::TracePropertyDef`, or `::String`
dataproperty(io,nm)    # returns the value held in the data property: `nm::String`
hasdataproperty(io,nm) # returns true if the data property corresponding to label `nm::String` is in `io::JSeis`
geometry(io)           # returns `Geometry`, the stored geometry of the dataset.  If no geometry is stored, `nothing` is returned</code></pre><p>Convenience methods are supplied for manipulating <code>io::JSeis</code>:</p><pre><code class="language-julia">rm(io)                      # remove (delete) the file and all of its extent files and secondary folders
empty!(io)                  # remove extends and secondary folders, but keep meta-data
cp(src, dst)                # create a new JavaSeis file `dst::AbstractString` that is a copy of `src::JSeis`, optional named argument: `secondaries=` - change file extents location
mv(src, dst)                # move a JavaSeis file to `dst::AbstractString` from `src::JSeis`, optional named argument: `secondaries=` - change file extents location
copy!(io, hdrs, io1, hdrs1) # copy values from `hdrs1::Array{UInt8,2}` to `hdrs::Array{UInt8,2}`</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« TeaSeis</a><a class="docs-footer-nextpage" href="../reference/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 5 August 2020 20:59">Wednesday 5 August 2020</span>. Using Julia version 1.5.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
